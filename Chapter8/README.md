# 第八章 MVC模式下的ThinkPHP 5.x开发框架的使用

古人云：“路遥知马力，日久见人心”。很多时候在讨论某一个框架好与坏的时候，只有真正的使用过，并深入了解过后才有发言权，如同讨论某某手机比某某手机好是一样的，只有两者都用过之后才能最终下结论。而框架的使用也是如此，一个框架如果能经过5-10年的发展，还依然被许多人所接受，那么它就一定有它的优势，哪怕是文档写的好，这也是优势，同时在这么多年的发展过程中框架本身也会不断吸收其他优秀框架的有点，让自己变的更加优秀。因此找一个合适自己的框架，并能够用该框架完成一些项目才是最关键，切不可一心追新、追变，就像PHP一样，诞生于上个世纪，但现在依然活跃在编程领域，甚至需求量还在逐年攀升。本章将着重讨论ThinkPHP的使用方法，以及相关工程应用，在这个过程中除了了解如何使用ThinkPHP去开发一个项目，还需要了解如果通过工程的思想来进行改造和升级。

#### 本章内容

> * MVC模式在Web开发中的应用
> * ThinkPHP框架的概述与项目部署
> * HTTP请求与ThinkPHP控制器的应用
> * ORM模型的创建与数据库的CURD操作
> * ThinkPHP内置模板引擎与视图的使用
> * ThinkPHP中路由的设置与URL的隐藏

## 8.1 MVC模式在Web开发中的应用

在Web开发中很多时候对于初学者或者不注重软件工程的开发人员来说，开发只是一个功能的实现，因此经常出现软件的前台和后台的代码混淆，造成后后期难以维护的结果，而那稍有些的开发经验的人则会想办法把各个模块进行独立，但是这样的操作通常不能适用于所有项目，因为要使现有程序从结构上进行分离，同时有需要满足可复用的要求是十分困难的，不过好在已经有程序设计的大神们帮助我们去实现了这一想法，并提供了一条可行的道路，即MVC模式。该模式的有点在于，它不和任何的语言进行绑定，而是一个经过无数软件验证的思想，是多年软件开发经验的高度总结。虽然采用这种方式会增加不少代码，但是不妨碍它成为使用最为广泛的软件架构模式。

### 8.1.1 MVC的工作模式和原理

所谓MVC，并不是一个单词，而是选取了三个英文单词的首字母，即Model（模型）、View（视图）、Controller（控制器），其中Model（模型）的作用表示建立的业务模型，以及响应各种查询业务，View（视图）则主要负责业务处理和查询结果的展示，以及传递用户请求，而Controller（控制器）则主要负责接收从View视图传递过来的用户请求，经过处理后传递给Model模型能够处理的数据，同时选择相应的视图View来进行展示，如图8-1所示。

![MVC](Screenshot/MVC.png)

图8-1 MVC模式中各模块的关系

在这个模型中最重要的就是Model模型的设计，因为它是整个业务的核心，整个业务的流程都在模型中完成，并且对外只提供简单的数据接口和业务请求类型，因此从模型的外部向里看是看到不到任何内容，也就是屏蔽了控制器和视图的的不同，如果把模型单独拿出来，也可以自成一个体系，只要业务内容和流程不发生改变，那么无论控制器和视图如何改变都不会影响到模型。其次就是Controller控制器，其主要功能就是承上启下，所谓“承上”就是指接收用户的各类请求，并且根据请求类型的不同，分发到各个模型中，而“启下”则是指在最终送到到模型前，把数据转化为模型能够接受的数据，使得从请求到执行能否顺畅运行，因此对于控制器来说，它屏蔽了视图成各种各样的请求，把这些请求化整为零，使得无论模型如何改变，又或者视图如何改变都可以在它们之间建立一个通畅的桥梁。最后就是View视图，其主要功能是接收用户各种各样的请求，例如点击提交、查看按钮等，此外还可以以不同形式展现模型中的数据，即可以为同一模型定制不同的视图或不同模型定义相同的视图。

因此采用MVC架构的程序能够满足用户需求快速变化的环境，例如制作上一个商城系统，其功能都是订单、购买、收藏等，而展示则可能采用仿照淘宝、京东或自己设计，此时整个系统的开发的焦点就只有View视图，而不包括其他部分，从而大大降低了重复代码，提高了可维护性。此外，当模型层有新的技术时也可以在保持整个业务逻辑不发生改变的情况进行修改和更新，所以MVC模式总结下来具有如下优势：

1、多个视图对应一个模型的能力

2、由于一个应用被分为三层，因此有时只需要改变其中的某一层就能满足需求，实现快速响应。

3、由于各层各司其职，有利于项目的工程化管理。

虽然MVC有诸多优点，但是从头开始实现MVC却不是一个容易的事，并且MVC只是一个顶层设计实现，而到达每一层后，还需要更为详细的设计，同时在MVC架构中View可以对模型进行操作，也就意味着在View中会有一部分对模型的依赖，使得View和Model之间没有完全的解耦，并且由于各层之间完全隔离，也使得需要更多的代码来实现该架构，增加了很多代码量。

### 8.1.2 常用的几种架构模式与PHP框架

除了上面讲到的MVC架构，实际上目前使用比较多的还有另外两种，分别是MVP和MVVM，这两种都是在MVC的基础上进行改进得来。例如在MVP架构中，直接抢断了视图View和模型Model之间关系，解决了MVC架构中View和Model没有完全解耦的问题，这是MVP和MVC架构最大的不同点。同时在MVP中把原先MVC的Controller控制器改为了Presenter，即呈现层，负责整个程序的逻辑，以及在Model和View之间做到承上启下的作用。而MVVM架构则是在MVP的基础上进行再次演进，把原先MVP中的Presenter改为了ViewModel，实现View和ViewModel之间的双向绑定，使得当View改变时会自动反应在ViewModel上，而当ViewModel改变时也会自动反应到View上，例如Google的Angular和Micsoft的WPF就是这种架构。

所谓开发框架，实际上就是使用某一种语言对某一种顶层架构模式的实现，以完成某一个问题领域类的任务，同时框架对诸多细节进行抽象，并使用设计模式来实现这些这些抽象后模块之间的解耦。因此框架并不会把所有的事情做完，更多的就像一个毛坯房，只不过这个房子已经装上了地暖、中央空调、新风等高级系统，但是里面如何装修等能让房子主人满意，这个就是装修设计师要完成的内容。另外使用框架有两个好处，首先开发人员在使用的过程中可以学习和了解这些框架的优点和缺点，在今后自己的开发中也可以借鉴这些优秀的思想，从而提高程序的质量，同时使用框架可以帮助开发人员屏蔽很多繁琐、重复的内容，使得开发人员可以把精力完全集中在业务逻辑的开发中，而且使用框架可以方便进行扩展和维护，并且框架还提供了许多细节处理，例如线程安全、IO安全等特性，从而提高软件的整体质量。

目前在PHP中，通用的框架有许多，但目前国内使用比较多的主要集中在下面四个，分别是Yii、Laravel、ZendFramework、ThinkPHP，其中Yii、Laravel、ZendFramework是由国外的开发人员进行维护和编写，而ThinkPHP则是由国内的开发人员进行维护和编写，下面对这几个框架进行简单的介绍：

1、Yii：由于该框架大量使用了延迟加载技术，即不会包含一个类文件，直到该类第一次使用，并且在第一次访问某个对象之前它不会创建该对象。所以Yii是一个高性能，基于组件的PHP框架，用于快速开发现代的Web应用程序。同时Yii还是实现了MVC架构的全栈框架，并基于该架构组织代码，并且对关系型数据库和NoSQL数据库都提供了查询生成器和ActiveRecord，也支持基于RESTful API开发等等。

2、Laravel：Laravel是一套简洁、优雅的PHP Web开发框架。它可以让开发人员从面条一样杂乱的代码中解脱出来，从而构建一个完善的网络APP，而且每行代码都可以简洁、富于表达力。在Laravel中已经具有了一套高级的PHP ActiveRecord实现。它能方便的将”约束”应用到关系的双方，这样开发人员就具有了对数据的完全控制，而且使用到ActiveRecord的所有便利。

3、ZendFramework：Zend Framework是PHP的母公司Zend公司开发的一套基于MVC架构的PHP开发框架技术，它提供了一个优秀的、简单的综合开发环境，提供了很多可用的解决方案，可以用来建立一个稳定的、可升级的的Web应用。同时Zend Framework还包含了PHP中所有的新技术，但是随着Zend Framework的不断发展，目前的Zend Framework已经非常庞大，而且复杂，所以不适合刚接触框架的人来学习。

4、ThinkPHP：ThinkPHP是国人开发的一个快速、简单，并且面向对象的轻量级的PHP框架，它也是免费、开源，可以用于任何商业软件开发的框架。同时，ThinkPHP还遵循PSR-2、PSR-4规范，并支持Composer和单元测试，框架内异常严谨的错误检测和安全机制，也使得开发的程序更加稳定，而RESTful的支持使得可以提供更好的API开发。这些特性的都保证ThinkPHP能够开发现代Web的所有功能，所以该框架的使用也是本书要讲的主要内容。

## 8.2 ThinkPHP框架的概述与项目部署

ThinkPHP自2006年诞生以来经过了10年的技术沉淀，目前已经国内开发PHP相关项目最主要的框架之一。ThinkPHP的设计理念源自Struts，并在其基础上做了大量的改进，同时还引入了许多国外优秀的框架思想和模式。目前ThinkPHP主要使用的版本有两个，分别是3.x和5.x，其中3.x是ThinkPHP获得成功的主要版本，并且得到了大量项目的使用和验证其可靠性，但是目前3.x已经完成了历史使命。在2017年的2月ThinkPHP发布了中5.x版本，该版本是在3.x的基础上进行全面的改写，具有更加规范、更加严谨、扩展更加灵活、全面支持Restful接口等特性，因此5.x版本和3.x版本并不兼容，建议在新项目上使用5.x进行开发，本章内容主要以最新的5.x为基础进行相关内容的讲解。

### 8.2.1 ThinkPHP的安装与目录结构

ThinkPHP是在PHP基础上的一个框架，因此它依赖于PHP作为其运行，目前ThinkPHP 5.x的运行环境需要PHP版本在5.4以上，并且至少安装了PDO、MBString、CURL这三个PHP插件，其中PDO用于实现数据库的存取、MBString用于实现字符编码的转换，而CURL则实现各种HTTP通信。在确认完运行环境之后就可以进行ThinkPHP的安装，目前ThinkPHP提供三种方式进行安装，分别如下：

1、第一种方法是进入ThinkPHP的官网（http://www.thinkphp.cn/），点击并下载右边的“ThinkPHP5.x完整版”，然后解压缩到Web服务器的目录下。

2、第二种方法是使用Composer工具进行下载，该工具是一个基于项目的PHP依赖管理工具，通过该工具可以为PHP项目添加相关依赖程序，例如PHP单元测试、symfony模板库等，类似与Android的Gradle。要使用Composer非常简单，对于Linux或者MAC用户来说只需要执行下面的指令即可完成安装，而Windows用户需下载Composer-Setup（https://getcomposer.org/Composer-Setup.exe）即可。

```bash
# 下载Composer
curl -sS https://getcomposer.org/installer | php
# 把下载的composer.phar修改为系统指令
mv composer.phar /usr/local/bin/composer
# 由于国内网络环境的原因，需要把composer的镜像源切换到国内镜像
composer config -g repo.packagist composer https://packagist.phpcomposer.com
```

在安装完Composer并切换到国内镜像后就可以通过Composer指令进行ThinkPHP的安装，在该指令中“--prefer-dist”选项的作用是告诉Composer直接下载不带Git信息的压缩包，具体指令如下：

```bash
composer create-project topthink/think 创建项目的名称 --prefer-dist
```

3、第三种则是使用Git进行安装，目前ThinkPHP被分为两个相对独立的模块，一个是ThinkPHP的应用模块，另一个是ThinkPHP的核心模块，因此要完整的使用ThinkPHP需要分别下载这两个模块，然后把它们组合起来使用。首先创建一个项目文件夹，然后通过Git指令克隆（clone）ThinkPHP的应用模块到该文件夹，然后在项目文件夹下创建一个文件夹叫thinkphp，最后进入thinkphp文件夹把ThinkPHP的核心模块的核心模块克隆（clone）到该文件夹即可，具体指令如下：

```bash
# 创建一个项目文件夹，并进入该目录
mkdir 项目文件夹;cd 项目文件夹
# 克隆（clone）ThinkPHP的应用模块到项目文件夹
git clone https://github.com/top-think/think
# 创建ThinkPHP模型模块文件夹thinkphp
mkdir thinkphp
# 克隆（clone）ThinkPHP的核心模块到thinkphp文件夹
git clone https://github.com/top-think/framework thinkphp
```

采用这三种方式所创建的项目都会有所区别，其中采用Git方式创建的项目是紧跟ThinkPHP官方的脚步，包括了所有最新的改动，但是这些改动可能不是非常稳定，而采用Composer方式创建的项目则是官方最新发布的正式版，即可以放心使用，最后就是去官网下载的方式，这种方式的有点是包含了很多第三方的库，但是不一定是最新版，但一定是一个稳定版。因此综合上面的说法，笔者在这里推荐采用Composer的方式进行安装，有以下三点原因：

1、目前不论国内还是国外，一个成熟的PHP项目都会采用Composer的方式来进行依赖管理，因此试着理解和学习Composer的使用对于今后和现在的工作都有很大好处。

2、使用官网下载的内容最大的优势在与包含了很多第三方的库，例如workerman、symfony等，但是实际上这些库实际上都可以通过Composer获取，并且获取的是最新稳定版。

3、通过Composer创建项目后，可以根据自己的需要添加和删除第三方库，从而动态整个项目的大小。

在本书中，所有的ThinkPHP的安装，以及依赖管理都采用Composer方式，因此在Web服务器的目录下执行下面的指令来创建一个名叫“tp5”的ThinkPHP项目，具体指令如下：

```bash
composer create-project topthink/think tp5 --prefer-dist
```

当执行完该指令后，就会在服务器目录下创建一个tp5的文件，该文件夹中包含了ThinkPHP的所有内容，最后在浏览器中输入“http://localhost/tp5/public/”就可以看到如图8-2所示的ThinkPHP欢迎界面，此时就表示ThinkPHP安装并初始化完成，接下来就可以开始编程。

![TP-init](Screenshot/TP-init.png)

图8-2 ThinkPHP初始化

要正确使用ThinkPHP进行项目开发，首先就需要了解ThinkPHP的目录结构，只有了解了其结构才能知道哪些地方是存放PHP代码，哪些地方是存放HTML代码等。首先进入到TP（下对ThinkPHP的简称）的目录，会看到有12个文件和文件夹，分别为application、extend、public、runtime、thinkphp、vendor、build.php、composer.json、composer.lock、LICENSE.txt、README.md、think，这12个文件和文件夹的功能分别如表8-1所示。

表8-1 TP根目录下的文件与文件夹说明

| 文件或文件夹名称 | 说明 |
| :-: | :- |
| application | 应用程序的目录，随后编写的程序都在该文件夹下 |
| extend | 扩展类库目录 |
| public | 供外部访问的目录，用于存放图片、JS库、入口文件等公共内容 |
| runtime | 应用的运行时产生的临时文件 |
| thinkphp | ThinkPHP的核心模块 |
| vendor | 存放使用Composer下载的第三方类库 |
| build.php | 自动生成定义文件 |
| composer.json | Composer依赖库的定义文件 |
| composer.lock | 保存使用Composer安装依赖库时的的版本号 |
| LICENSE.txt | 开源软件的证书文件 |
| README.md | 项目说明文件 |
| think | 命令行的入口文件 |

在这些文件和文件夹中，有一个文件夹需要特别说明，即application，该文件夹是项目构建的核心文件夹，是应用程序主要编写和存放的地方，进入到该文件夹下有6个文件和1个文件夹，分别为index、command.php、common.php、config.php、database.php、route.php、tags.php，这7个文件和文件夹的分别如表8-2所示。

表8-1 application目录下的文件与文件夹说明

| 文件或文件夹名称 | 说明 |
| :-: | :- |
| index | 应用程序的模块目录 |
| command.php | 命令行工具配置文件 |
| common.php | 应用程序公共函数文件 |
| config.php | 应用程序公共配置文件 |
| database.php | 数据库配置文件 |
| route.php | 路由配置文件 |
| tags.php | 应用行为扩展定义文件 |

这些文件和文件夹的意义从上表中可以清楚的知道，但是index却不是特别清楚。在编写一个完整的应用程序时，通常会包含前台、后台、移动端等各种各样独立的系统，这些系统在TP体系中就称为模块。在TP中模块的概念是一个独立的，并且具有完整功能的系统，例如前台模块中可以有自己的UI、可以有自己的数据库操作、可以有自己的HTTP通信等，而后台也可以包含这些功能，两者之间相互独立，当然后期也可以通过一些设置来实现模块和模块之间某些部分的公用，总之每一个模块下都会按照MVC架构进行文件夹和文件的排列，例如现在进入index目录就可以看到一个controller文件夹，该文件夹里面的内容就是控制器，而其他View和Model在后面的讲解中会不断创建。因此可以根据项目的需求在application目录下创建多个与index目录平行的模块文件夹来进行区分。

### 8.2.2 ThinkPHP的体系结构与生命周期

为了更加清楚的了解TP的体系结构，有一些概念需要提前说明，因为这些概念都会贯穿于本章的所有内容，同时在今后的项目开发中也起到非常重要的作用，并且在了解这些概念后，也为之后学习其他框架建立一个良好的基础。在TP中有十个概念非常重要，具体如下：

**1、入口文件：** 该文件是所有请求的入口，其作用有两个，首先该文件指定了TP核心框架的路径，使得在所有请求中都能载入TP的框架代码，其次该文件还制定的应用的路径，最后在TP中因为只有载入入口文件的请求才有可能成功，所以防止具有敏感信息的页面被直接访问。

**2、应用：** 在TP中应用是一个完整的待开发的系统，并且也是TP生命周期的执行对象。通常来说，一个应用就是一个TP的项目，但一个项目却可以有多个模块，上节在讲目录结构时提到的application其实就是这里的应用。

**3、模块：** 这个概念在上节讲过，即一个应用的通常会有单独的模块，如前台、后台等，并且这些模块具有各自独立的配置文件、公共文件等。

**4、控制器：** 每个模块拥有独立的MVC模型，并且每个模块下面都会有多个控制器负责响应请求，每个控制器就是一个独立的控制器类。控制器主要负责接收各类请求，并调用相关的业务模型进行处理，并选择相应的视图进行输出，但是这里有一点要说明的是，从MVC模型的角度来说控制器应该只负责业务流程的分发，而不负责业务的逻辑处理。

**5、操作（方法）：** 所谓方法就是控制器内的函数，一个控制器内可以有多个操作，并且这些操作是真正接收请求和执行请求的对象。

**6、模型：** 模型是整个TP的核心模块，该模块主要用于数据操作和业务逻辑，并且返回和视图无关的数据。很多在刚入门TP时会把模型只作为对数据库操作的对象，但是实际上这只是TP的一部分功能，更多的应该是对模型进行更加细致的分层设计，从而实现整个业务的逻辑层、数据层等。

**7、视图：** 控制器根据请求的不同调用不同的视图模板，这些模板由HTML、CSS、JavaScript组成，最后根据视图数据的类型把从模型中获取的无格式数据进行转化，填入模板中，从而呈现在Web端。

**8、驱动：** 所谓驱动可以理解某一个组件的扩展，例如数据库驱动、缓存驱动等，但是这些驱动都提供了统一的接口，方便TP进行读写操作和驱动扩展。

**9、行为：** 把一类被频繁使用的操作进行抽象和隔离，然后让多个不同的流程共用这一个流程，通过行为的使用可以让TP根据更加通用的灵活性。

**10、命名空间：** 简单说就是把各种类进行分类，当这些分类中有冲突时，加上命名空间，以区分各自的不同。

这些概念中，有些非常好理解，比如入口文件、控制器等，而有些就不是特别好理解，如驱动、行为等，不需要担心，这里只是做一个简单介绍，在后续的内容中会具体讲解。在了解了TP中的概念之后，接下来就来了解TP程序运行的生命周期，对于生命周期的理解能够帮助读者更加清楚的了解整个程序运行流程，并且在未来修改程序时也能够知道在哪里修改最为合适。一个完整的TP生命周期包含了十个步骤，具体如下：

**第一步：入口文件，**用户发起一个请求，首先经过的就是入口文件。TP的入口文件位于public目录下的index.php文件。该文件中首先定义了一个指定应用程序入口位置的常量“APP_PATH“，在默认情况下应用程序的入口位置在application目录下，其中“\_\_DIR\_\_”是PHP的一个常量表示当前文件的路径，因此"\_\_DIR\_\_ . '/../application/'"就表示当前文件的上一级目录下的application文件夹，即应用程序的根目录。其次该文件执行并导入了框架的引导文件start.php，该文件位于与application同级的thinkphp目录下，具体代码如下：

```php
// 定义应用目录
define('APP_PATH', __DIR__ . '/../application/');
// 加载框架引导文件
require __DIR__ . '/../thinkphp/start.php';
```

**第二步：执行引导文件，**在引导文件里，首先加载了项目初始化文件base.php，在该文件中首先完成了TP系统常量的定义，其次加载环境变量定义文件，然后注册了系统自动加载机制和注册系统错误和异常的处理机制，最后加载系统配置文件。当这些都完成后就执行应用程序，具体代码如下：

```php
// 加载基础文件
require __DIR__ . '/base.php';
// 执行应用
App::run()->send();
```

**第三步：注册自动加载程序，**当引导程序完成环境变量的定义之后，就会注册自动加载的程序，这些程序首先会注册自动加载程序autoload，然后就加载包括使用Composer安装的相关依赖，命名空间，以及extend目录下的程序等，具体代码如下。有兴趣的读者可以查看该自动加载的源代码，位于"thinkphp\library\think\Loader.php"。

```php
// 注册自动加载
\think\Loader::register();
```

**第四步：注册系统错误和异常处理程序，**注册完自动加载后就是注册系统错误和异常处理，这里一共注册了三种处理函数，分别是应用关闭函数appShutdown、错误处理函数appError以及异常处理函数appException。当整个程序发生异常时程序的执行会停止，那么此时TP就会捕捉到这些异常，并显示这些错误。

```php
// 注册错误和异常处理机制
\think\Error::register();
```

**第五步：应用初始化，**在该阶段主要是加载应用程序的各类配置文件，以及公共函数，并设置时区等。当执行完这些之后，整个TP内部已经初始化完毕，接下来就是对用户请求进行分析。

**第六步：URL正确性检测，**到这一步会检查请求的地址时候符合规范，在TP中典型的请求地址包括服务器地址、入口文件、模块、控制器、操作，以及函数等，并且不区分大小写，因此如果传递的请求中包含大写字母时，也会被系统自动转成小写字母，一个标准的URL请求如下：

```http
http://serverName/index.php/模块/控制器/操作/[参数名/参数值...]
```

在8.2.1节中通过Composer创建了名字为tp5的TP后，在浏览器中输入”http://localhost/tp5/public/“就可以看到TP的欢迎界面，这是因为默认创建的控制器和方法都是以Index命名，所以浏览器就直接读取，而完整的URL请求应该如下：

```http
http://localhost/tp5/public/index.php/index/index/index
```

在这个URL中public/index.php表示读取入口文件，而后面第一个index表示的是application目录下的index模块，第二个index则表示在index模块下的controller文件夹下的index控制器，该控制器的文件名为Index.php，因为在TP中URL不区分大小写，因此这里不论是写index或者Index都会被转化为index，而最后一个index则表示在index控制器index方法，打开Index.php就可以看到该方法。接下来在Index.php中添加一个函数叫helloWorld()，具体代码如下：

```php
class Index
{
    public function index()
    {
        return 'xxx';
    }

    public function helloWorld()
    {
        return "Hello World";
    }
}
```

然后在浏览器中重新输入地址”http://localhost/tp5/public/index.php/index/index/helloWorld“就可以看到浏览器输出”Hello World“，表示请求成功。

**第七步：路由检测，**从第六步的例子可以初步看出，一个完整的URL是非常长的，那么路由的目的就在于简化URL，使得URL的表达更加的简洁和明确。

**第八步：分发请求，**不论时候检测到路由，此时TP都会把URL转化为真实的地址，这是整个生命周期中非常重要的一个环节，在该阶段TP会根据真实的URL寻找对应的模块、控制器和方法，并执行这些方法。

**第九步：响应输出，**在第六步中看到，不论index还是helloWord都是采用return的方式进行数据返回，而不是采用echo函数，这是因为当控制器return后，TP内部还会调用系统的Response::send方法将需要返回的数据输出到页面或者客户端，此时的关键在于采用return返回时，如果返回的不是HTML，那么就会把数据转化为在配置文件中配置的数据类型，如JSON、XML等，而采用echo输出则不会自动转换，因此对于采用return方式返回的数据不需要考虑类型转换，比echo返回简化了许多操作。

**第九步：应用结束，**实际上到了这一步，基本上已经和开发人员没有太大的关系，剩下的就是TP内部的日志操作等。

到这里TP的整个生命周期和体系结构就已经讲清楚了，从上面的内容可以看到，对于开发人员来说，除了模型的构建外，最重要的就是控制器和方法的实现，因为这个是数据请求的唯一途径，而且对于某些应用来说，如微信小程序、APP等，是不需要实现视图，至于后面的路由等功能都是在完成模型和控制器基础上的进一步优化。

### 8.2.3 ThinkPHP的系统配置和配置作用域

在使用TP时经常需要进行一些数据库配置、路由配置等，而TP中的配置信息采用数组的方式进行部署，并且当TP读取这些配置项时，TP会把这些配置项名称不论大小写都自动转化为小写，因此对于TP来说配置项名称不区分小写，并且TP还支持在数组里面套用多维数组的方式进行配置，从而提供更加丰富的配置内容，示例代码如下：

```php
return [
    // 配置向信息
    '配置项名称' =>  '配置项的值',
    // 二维数组的配置项
    '配置项名称' => [
        '配置项名称' => '配置项的值',
        // ...
    ],
    // ...
];
```

为了获得最大的灵活性，在TP中配置项采用六层配置模式，即全局配置、应用配置、扩展配置、场景配置、模块配置、动态配置，这些配置由前到后依次被覆盖，也就是说如果应用配置中的配置项和全局配置的配置项冲突时，TP就会采用应用配置项的内容，而如果模块配置项和应用配置项冲突了，那么就会采用模块配置项的内容，使用这种方式可以非常灵活的实现公用配置和个别配置之间的分离。

在TP项目的thinkphp目录下有个convention.php文件，该文件是TP项目的默认全局配置文件，里面包含了应用设置、模块设置、URL设置等，但是该文件通常不需要修改，因为这是全局的配置文件，牵涉到整个TP的正常运行。如果需要修改某些配置项，那么应该在后续的配置文件中进行设置。此外，这里有个注意点，即观察convention.php文件可以看出所有的配置项都采用小写的方式进行编写，这也是在5.x之后官方所推荐的方式。

全局配置的上一层就是应用配置，该配置项位于TP的application目录下，并且由四个文件组成，分别是config.php、database.php、route.php、tags.php，其中database.php表示数据库相关配置，route.php表示路由相关配置，tags.php表示应用行为的扩展定义，而除了数据库、路由、应用行为扩展等信息之外的所有配置项都是在config.php文件完成配置，如图8-3所示。

![application-config](Screenshot/application-config.png)

图8-3 ThinkPHP的应用配置项

在应用配置之后就是扩展配置，到笔者写书为止，TP的版本是5.0.10，而在5.0.1版本之前TP可以使用extra_config_list的配置参数来定义扩展配置，但是在5.0.1之后TP放弃这个做法，而是采用更为简洁的方式，即只要在application目录下创建extra文件夹，并且在该文件夹中创建PHP文件，同时在该文件中返回一个配置数组，如图8-4所示。

![extra-config](Screenshot/extra-config.png)

图8-4 ThinkPHP的扩展配置项

在创建完扩展配置文件之后就可以通过TP提供的配置读取函数进行参数的读取，在TP中参数的读取有两个函数，分别是Config::get()和config()，通过向这两个函数传递配置项名称就可以获取配置项的值，实际上config()函数是Config::get()函数的在封装，具体代码如下：

```php
/**
* 获取和设置配置参数
* @param string|array  $name 参数名
* @param mixed         $value 参数值
* @param string        $range 作用域
* @return mixed
*/
function config($name = '', $value = null, $range = '')
{
    if (is_null($value) && is_string($name)) {
        return 0 === strpos($name, '?') ? Config::has(substr($name, 1), $range) : Config::get($name, $range);
    } else {
        return Config::set($name, $value, $range);
    }
}
```

上面的代码就是如何通过封装使config()函数实现参数的读取、设置，以及时候存在的判断，其中$range表示参数数组中二维数组的数组名。在该函数中，首先判断参数值$value时候为空，并且参数名称$name时候是字符串，如果满足$value为空且$name为字符串，那么就表示读取参数，然后通过strpos()函数判断字符“?”时候存在于参数名称的第一个位置，如果“?”在第一个位置，那么就通过Config::has()函数判断参数时候存在，如果“?”不在第一个位置，那么就通过Config::get()函数获取参数。如果不满足$value为空且$name为字符串，那么就通过Config::set()函数进行参数的设置。

## 8.3 HTTP请求与ThinkPHP控制器的应用

### 8.3.1 控制器的创建与重定向

### 8.3.2 RESTful的概念与Rest控制器的使用

### 8.3.3 HTTP的请求获取与参数绑定

## 8.4 ORM模型的创建与数据库的CURD操作

### 8.4.1 数据库的的参数配置

### 8.4.2 ORM数据库模型的定义与初始化

### 8.4.3 使用模型的的CURD操作

## 8.5 ThinkPHP内置模板引擎与视图的使用

### 8.5.1 视图初始化与模板中值的传递

### 8.5.2 特殊字符的替换与模板继承

## 8.6 ThinkPHP中路由的设置与URL的生成

### 8.6.1 路由的定义与批量注册

### 8.6.2 路由的参数设置与分组

### 8.6.3 路由的绑定与URL生成

## 8.7 小结